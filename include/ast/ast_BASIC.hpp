#ifndef ast_BASIC
#define ast_BASIC

// Defines basic super classes that are needed for the parse tree as well as classes that do not
// come under any other category (e.g. null statements)

//  - Super Program class: line 17 (defined in separate cpp file)
//  - Null Statement class: line 75
//  - Typedef statement class: line 95
//  - Typedef of struct class: line 117
//  - Sequence of statements class: line 148 (defined in separate cpp file)
//  - Sizeof operator class: line 168
//  - Ternary if operator class: line 266

//-----------------------------------------------------------------------------------------------------------

//THE MAIN PROGRAM POINTER - all classes inherit from this superclass and use its virtual functions.

class Program;

typedef const Program* ProgramPtr;

class Program
{
  public:
    // Constructors
    Program() {}
    Program(ProgramPtr p);
    // Destructor
    virtual ~Program();

    // Used to print Python translation:
    //    - tabs is used to keep track of how many tabs we are currently indenting Python code.
    //    - globals keeps track of global variables (need to declare with global keyword within functions)
    //    - os is output stream object reference
    virtual void PythonPrint(int tabs, std::map<std::string, std::string>& globals, std::ostream& os) const;
    // Used in generating MIPS:
    //    - c carries contextual information (see ast.hpp)
    //    - os is output stream reference
    //    - sp_off is the current offset of stack pointer
    //    - destreg is the destination register of the MIPS assembly operations (useful for operations like addition)
    virtual void MIPSPrint(Context& c, std::ostream& os, int sp_off, std::string destreg) const;

    // Used to identify class/identifier information:
    // Identifies what is the class type
    virtual std::string Whatami() const;
    // Identifies the identifier used to name variable/function
    virtual std::string Name() const;
    // Identifies type of function call statement/variable
    virtual std::string MyType(Context& c) const;

    // Lookahead functions used to perform analysis for preallocation of memory
    // Memory size of sub components in larger component (e.g. memory size generated by statements in a for loop)
    virtual int compsize() const;
    // Returns memory size generated by variable declarations
    virtual int countdeclarations(Context& c) const;
    // Returns maximum number of parameters in any function call (we need to different things if <4 or >4)
    virtual int maxparams(Context& c) const;
    // Find any char* declarations allocated to C-string so that we can allocate heap memory.
    virtual int findstrings(std::map<std::string, std::string>& slabel) const;

    // return int value of an integer constant - useful for declarations like 'int a = 2+3;'
    virtual int intvalue(Context& c) const;
    // same as above but for double constant
    virtual double dblvalue(Context& c) const;
    // Used in parser to build parse tree.
    void addcomponent(ProgramPtr p);

  protected:
    // A parse tree node may have unlimited children based on how many components (different subclasses) they contain.
    std::vector<ProgramPtr> components;
};

//----------------------------------------------------------------------------------------------------------------------------
//NULL STATEMENT i.e. ;

class NullStatement : public Program
{
  public:
    NullStatement() {}

    std::string Whatami() const
    {
      return "NullStatement";
    }

    void PythonPrint(int tabs, std::map<std::string, std::string>& globals, std::ostream& os) const {}
    void MIPSPrint(Context& c, std::ostream& os, int sp_off, std::string destreg) const
    {
      os << "nop" << std::endl;
    }
};

//---------------------------------------------------------------------------------------------------------------------
//TYPEDEF

class Typedef : public Program
{
  public:
    Typedef(std::string type, std::string id): masked_type(type), identifier(id) {}

    std::string Whatami() const
    {
      return "Typedef";
    }

    void MIPSPrint(Context& c, std::ostream& os, int sp_off, std::string destreg) const
    {
      c.userdefs[identifier] = masked_type;
    }
  private:
    std::string masked_type;
    std::string identifier;
};

//-----------------------------------------------------------------------------------------------------------
//TYPEDEF STRUCT

class TypedefStruct : public Program
{
  public:
    TypedefStruct(ProgramPtr decl_struct, std::string id): decl_struct(decl_struct), identifier(id) {}
    ~TypedefStruct()
    {
      delete decl_struct;
    }

    std::string Whatami() const
    {
      return "TypedefStruct";
    }
    std::string Name() const
    {
      return identifier;
    }

    void MIPSPrint(Context& c, std::ostream& os, int sp_off, std::string destreg) const
    {
      decl_struct->MIPSPrint(c, os, sp_off, destreg);
      c.userdefs[identifier] = "struct " + decl_struct->Name();
    }
  private:
    ProgramPtr decl_struct;
    std::string identifier;
};

//------------------------------------------------------------------------------------------------
//SEQUENCE OF STATEMENTS

class Sequence : public Program
{
  public:
  Sequence(ProgramPtr s): Program(s) {}

  int setvpframe(int val);

  std::string Whatami() const;

  int countdeclarations(Context& c) const;
  int maxparams(Context& c) const;
  int findstrings(std::map<std::string, std::string>& slabel) const;

  void PythonPrint(int tabs, std::map<std::string, std::string>& globals, std::ostream& os) const;
  void MIPSPrint(Context& c, std::ostream& os, int sp_off, std::string destreg) const;
};

//--------------------------------------------------------------------------------------------------------
//SIZEOF OPERATOR

class Sizeof : public Program
{
  public:
    Sizeof(std::string type): expression(NULL), sizetype(type) {}
    Sizeof(ProgramPtr exp): expression(exp), sizetype("") {}
    ~Sizeof()
    {
      delete expression;
    }

    std::string Whatami() const
    {
      return "Sizeof";
    }
    std::string MyType(Context& c) const
    {
      return "int";
    }

    int maxparams(Context& c) const
    {
      if(expression != NULL)
      { return expression->maxparams(c); }
      else
      { return 0; }
    }

    void MIPSPrint(Context& c, std::ostream& os, int sp_off, std::string destreg) const
    {
      std::string type;
      int multiplier = 1;
      int size = 0;
      bool is_string = false;
      if(expression == NULL)
      {
        type = reducetype(c.userdefs, sizetype);
      }
      else
      {
        type = reducetype(c.userdefs, expression->MyType(c));
        if(expression->Whatami() == "Variable")
        {
          if(c.arrays.find(expression->Name()) != c.arrays.end())
          { multiplier = c.arrays.at(expression->Name()); }
        }
        else if(expression->Whatami() == "StringLiteral")
        {
          is_string = true;
          size = expression->compsize();
        }
      }
      if(!is_string)
      {
        if((type == "char")||(type == "unsigned char")||(type == "signed char"))
        {
          size = 1;
        }
        else if((type == "short")||(type == "unsigned short")||(type == "signed short"))
        {
          size = 2;
        }
        else if((type == "int")||(type == "unsigned int")||(type == "signed int"))
        {
          size = 4;
        }
        else if((type == "long")||(type == "unsigned long")||(type == "signed long"))
        {
          size += 4;
        }
        else if(type == "float")
        {
          size = 4;
        }
        else if(type == "double")
        {
          size = 8;
        }
        else if(type[type.size() - 1] == '*')
        {
          size = 4;
        }
        else if(isStruct(type))
        {
          std::string id = type.substr(7);
          size = StructSize(c.userdefs, (c.structs).at(id));
        }
      }
      size = size*multiplier;
      os << "li         " << destreg << ", " << size << std::endl;
    }
  private:
    ProgramPtr expression;
    std::string sizetype;
};

//--------------------------------------------------------------------------------------------------------------------------
//TERNARY CONDITIONAL

class ternaryif : public Program
{
  public:
    ternaryif(ProgramPtr condition, ProgramPtr e1, ProgramPtr e2): cond(condition), expression1(e1), expression2(e2) {}
    ~ternaryif()
    {
      delete cond;
      delete expression1;
      delete expression2;
    }

    std::string Whatami() const
    {
      return "ternaryif";
    }
    std::string MyType(Context& c) const
    {
      if(expression1->MyType(c) == expression2->MyType(c))
      {
        return expression1->MyType(c);
      }
      else
      {
        return "";
      }
    }

    int maxparams(Context& c) const
    {
      int con = cond->maxparams(c), e1 = expression1->maxparams(c), e2 = expression2->maxparams(c);
      if(con >= e1)
      {
        if(con >= e2)
        {  return con; }
      }
      else
      {
        if(e1 >= e2)
        {  return e1; }
      }
      return e2;
    }

    int findstrings(std::map<std::string, std::string>& slabel) const
    {
      return cond->findstrings(slabel) + expression1->findstrings(slabel) + expression2->findstrings(slabel);
    }

    void MIPSPrint(Context& c, std::ostream& os, int sp_off, std::string destreg) const
    {
      expression2->MIPSPrint(c, os, sp_off, "$10");
      if(expression1->Whatami() == "ternaryif")
      {
        stpushreg("$10", os);
      }
      expression1->MIPSPrint(c, os, sp_off, "$9");
      if(expression1->Whatami() == "ternaryif")
      {
        stpopreg("$10", os);
      }
      if(!IsOperand(cond->Whatami()))
      {
        stpushreg("$9", os);
      }
      cond->MIPSPrint(c, os, sp_off, "$8");
      if(!IsOperand(cond->Whatami()))
      {
        stpopreg("$9", os);
      }
      std::string label1 = makeName("L");
      std::string labelend = makeName("L");
      os << "beq        $8, $0, " << label1 << std::endl;
      os << "nop" << std::endl;
      os << "move       " << destreg << ", $9" << std::endl;
      os << "b          " << labelend << std::endl;
      os << "nop" << std::endl;
      os << label1 << ":" << std::endl;
      os << "move       " << destreg << ", $10" << std::endl;
      os << labelend << ":" << std::endl;
    }
  private:
    ProgramPtr cond;
    ProgramPtr expression1;
    ProgramPtr expression2;
};


#endif
